* ## Какие существуют уровни веб-приложения? За что отвечает каждый из них? 

    * **Уровень представления (PL)** - построенный с помощью HTML, CSS, JavaScript и их фреймворков, обеспечивает связь между интерфейсом и браузером для облегчения взаимодействия с пользователем. Основная цель уровня представления - получить входные данные, обработать запросы пользователей, отправить их в службу данных и показать результаты. 

    * **Уровень бизнес-логики (BLL)** - бизнес-уровень определяет бизнес-логику и правила, несет ответственность за надлежащий обмен данными. Он обрабатывает запросы браузера, выполняет бизнес-логику, связанную с запросами, а затем отправляет их на уровень представления.

	* **Уровень обслуживания данных (DSL)** - уровень базы данных или уровень службы данных передает данные, обработанные уровнем бизнес-логики, на уровень представления и обеспечивает безопасность данных, отделяя бизнес-логику от клиентской стороны.

	* **Уровень доступа к данным (DAL)** - предлагает упрощенный доступ к данным, хранящимся в постоянных хранилищах, таких как двоичные файлы и файлы XML. Уровень доступа к данным также управляет операциями CRUD - создание, чтение, обновление, удаление.  

* ## Что такое монолитная и микросервисная архитектуры веб-приложения?

    * **Монолитная архитектура** — это традиционная модель программного обеспечения, которая представляет собой единый модуль, работающий автономно и независимо от других приложений. Это отдельная большая вычислительная сеть с единой базой кода, в которой объединены все бизнес-задачи. Чтобы внести изменения в такое приложение, необходимо обновить весь стек через базу кода, а также создать и развернуть обновленную версию интерфейса, находящегося на стороне службы. Это ограничивает работу с обновлениями и требует много времени.
    * **Микросервисная архитектура** (или просто «микросервисы») представляет собой метод организации архитектуры, основанный на ряде независимо развертываемых служб. У этих служб есть собственная бизнес-логика и база данных с конкретной целью. Обновление, тестирование, развертывание и масштабирование выполняются внутри каждой службы.  

* ## Каковы различия между монолитом и микросервисами?  

    Под **монолитом** понимают приложение как неделимую единицу. Традиционно монолитное решение — один исполняемый файл на стороне сервера и еще один — на стороне клиента.
    Архитектура **микросервисов** представляет собой приложение, состоящее из множества различных сервисов, каждый из которых выполняет свою определенную функцию.

* ## Почему не все приложения построены на микросервисной архитектуре?

    **Микросервисы** несут в себе определенную сложность. Каждый отдельный сервис физически изолирован от остального приложения, процесс разработки более сложный, что влечет за собой рост расходов на инфраструктуру, дополнительные организационные расходы, усложнение отладки, отсутвие стандартизации, снижение производительности, сложность регриссионного тестирования. Архитектура микросервисов выгодна для больших и сложных проектов, поскольку каждый сервис может быть изменен без ущерба для других блоков. А вот если приложение не слишком большое и не вызывает проблем с масштабированием, требования к сервису (например, к веб-сайту) включают только скорость, доступность и возможность обслуживания статического контента, который находится в свободном доступе, **монолитная** архитектура для таких целей — вполне естественный выбор. А всё остальное было бы чрезмерным усложнением.
 
* ## Каковы особенности тестирования монолитных и микросервисных веб-приложений?

    Протестировать **монолитное приложение** гораздо проще, чем микросервисы. Можно запустить и протестировать приложение на сервере разработчика или в промежуточной среде, а также применить стандартный процесс развертывания для проверки изменений перед запуском приложения в продакшн. Однако в монолите высокий уровень зависимостей. Единый код означает, что компоненты тесно связаны, и изменения в логике одного модуля или службы сопряжены с гораздо более высоким риском влияния на код и работу других модулей. Порой трудно предсказать последствия для приложения даже после небольших изменений в коде. Поэтому каждое обновление вынуждает повторно тестировать весь продукт.
    Архитектура **микросервисов** и разбиение уже работающего приложения на отдельные, слабо связанные между собой сервисы означает, что новые возможности и функции могут быть проверены и добавлены без риска остановки приложения. С одной стороны, тестировать отдельные микросервисы проще, с другой, необходимость тестировать каждый сервис по отдельности может значительно усложнить приложение по мере его масштабирования. А необходимость тестировать и поддерживать связь между службами создает дополнительную сложность. Важно уделять время юнит-тестированию либо компонентному тестированию, так как не все процессы можно проверить на интеграционном уровне. 



